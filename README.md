## Порівняння ефективності жадібного алгоритму та динамічного програмування

Я протестувала обидва алгоритми (`Greedy` і `DP`) на чотирьох наборах умов:

Класичний набір, мала сума      | 133      | [50, 25, 10, 5, 2, 1]
Класичний набір, велика сума    | 100 856  | [50, 25, 10, 5, 2, 1]
Нестандартний набір, мала сума  | 27       | [10, 9, 1]
Нестандартний набір, велика сума| 100 856  | [11, 7, 5, 1]

### Результати часу виконання в секундах

Класичний набір, мала сума      | Greedy Time 0.000026    | DP Time 0.000126
Класичний набір, велика сума    | Greedy Time 0.000006    | DP Time 0.076344
Нестандартний набір, мала сума  | Greedy Time 0.000006    | DP Time 0.000014
Нестандартний набір, велика сума| Greedy Time 0.000002    | DP Time 0.052427

### Висновки

1. **Greedy алгоритм завжди працює набагато швидше**, навіть на дуже великих сумах. У всіх тестах він займав **мікросекунди**, тоді як DP займав **до 0.07 секунд**.
2. Для **класичних монет** (1, 2, 5, 10, 25, 50) обидва алгоритми дають **однаковий результат**, тому в таких випадках **Greedy це кращий вибір** завдяки швидкості.
3. Для **нестандартних монет** (`[10, 9, 1]` або `[11, 7, 5, 1]`) **Greedy може дати не мінімальну кількість монет**:
  3.1. Наприклад, для суми `27`:
    - `Greedy` дає `{10: 2, 1: 7}` — 9 монет
    - `DP` дає `{9: 3}` — всього 3 монети
  3.2. Для великої суми з нестандартним набором `DP` також дає **менше монет**.
  Тобто:  
  - **Greedy**: швидкий, але іноді неточний  
  - **DP**: завжди точний, але повільніший, особливо на великих сумах

Отже:
- Жадібний підхід ефективний, коли набір монет **стандартизований**.
- Динамічне програмування треба використовувати, коли важлива **мінімальна кількість монет** або набір номіналів **нестандартний**.